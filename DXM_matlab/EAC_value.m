% For more details see      Cyclostationnarity analysis of enso memory
%                           Student research report - 2011
%                           Audrey LUSTIG  

% EAC_profile.m
%   Calculate the EAC value for a DXM map of quasi-period d such as pmin<=d<=pmax.  
%   (This program is automatically called  by DXM_analysis)
% INPUTS :
%   S : inpout signal (vector)
%   n : length of the inpout signal (length(S)) (integer)
%   pmin,pmax : range of width of the DXM map, x time resolution (integers)
%   umax,vmax : width and height of the reference sub-map (integers) 
% OUTPUTS:
%   EAC_profile = Return the EAC value for a DXM map of quasi-period d such as pmin<=d<=pmax. 
function EAC_profile=profile(S,n,umax,vmax,pmin,pmax)
    EAC_profile=[];
    for d=pmin:pmax
        EAC=make_all(S,n,d,umax,vmax);
        EAC_profile=[EAC_profile EAC];
    end

    
% make_all.m
% Calculate the EAC value for a DXM map of quasi-period d. 
function EAC=make_all(S,n,d,umax,vmax)
    k=(n-mod(n,d))/d;
    M=make_DXM_map(S,n,d);
    a=0;
    i=0;
    for x=(umax+2):(d-(umax+1))
        for y=(vmax+2):(k-(vmax+1))
            d=getA(M,y,x,umax,vmax);
            if (~isnan(d))
                a=a+d;
                i=i+1;
            end
        end
    end
    if (i~=0)
        EAC=a/i;
    else
        EAC=NaN;
    end
    
    
% getA
% Calculate the correlation between a reference sub-map centred on (x,y) of  
% size (2umax+1)*(2vmax+1) to target sub-maps of the same size, sampled
% over a pre-appointed searching region around (x,y).
% INPUTS :
%   M : DXM map automatically generated by the function make_DXM_map
%   (matrix)
%   x,y : coordonates of a point in the DXM map (integers)
%   umax,vmax : width and height of the reference sub-map (integers)
% OUTPUTS:
%   s = average correlation between a reference sub-map centred on (x,y)
%       and the surrounding target sub-maps 
function s=getA(M,x,y,umax,vmax) 
    mxy=getM(M,x,y,umax,vmax); % extraction of the square matrice of size (2*umax+1)*(2*vmax+1) centered on x,y
    add=0;
    i=0;
    for u=x-1:x+1              % definition of the pre-appointed searching region around (x,y)
        for v=y-1:y+1
            if (u~=x | v~=y)
                muv=getM(M,u,v,umax,vmax); % extraction of the square matrice of size (2*umax+1)*(2*vmax+1) in the searching region around (x,y)
                corr=(mxy.*muv); % calculate the correlation by ingniring NaN values
                corr_val=sum(corr(~isnan(corr)));
                nb_value=length(corr(~isnan(corr)));
                if (~isnan(corr_val))
                	add=add+corr_val*nb_value;
                    i=i+nb_value;
                end
            end
        end
    end
    if (i~=0)
        s=add/i;
    else
        s=NaN;
    end
    
    
% getM
% We defne the neighborhood of(x,y)
% such as |x-x_i|<=umax and |y-y_i|<vmax where x_i and y_i are the 
% coordinates of the neighbors.
% We return the centered and normalized neighborhood matrix 
% INPUTS :
%   M : DXM map automatically generated by the function make_DXM_map
%   (matrix)
%   x,y : coordonates of a point in the DXM map (integers)
%   umax,vmax : width and lon of the sliding window (integers)
% OUTPUTS:
%   r = centered and normalized neighborhood matrix of(x,y) (matrix)
function r=getM(M,x,y,umax,vmax)
    window=M((x-umax):(x+umax),(y-vmax):(y+vmax));
    me= mean(window(~isnan(window)));  % average of the neigboorhood of x,y (NA's values are ignored)
    sd= std(window(~isnan(window)));   % standard deviation of the neigboorhood of x,y (NA's values are ignored)
    r=(window-me)/sd; 
    
    
    